function solution_print ( x, label, tile_num, tile_word, grid_word )

%*****************************************************************************80
%
%% solution_print() prints a solution generated by cplex().
%
%  Discussion:
%
%    This function assumes:
%    * there was an LP file generated;
%    * the linear system defined by the LP file was solved by cplex();
%    * the binary solution vector has been extracted by cplex_solution_read().
%
%    This function then produces a list of the elements covered by each tile,
%    and their vertex (i,j) coordinates.
%    
%  Licensing:
%
%    This code is distributed under the GNU LGPL license.
%
%  Modified:
%
%    16 November 2021
%
%  Author:
%
%    John Burkardt
%
%  Input:
%
%    integer X(*), the solution file, containing 4 1's.  Each 1 occurs
%    at an index which encodes the rotation, reflection and translation
%    of one of the tiles.
%
%    string label: a string to identify the region.
%
%    integer tile_num: the number of tiles.
%
%    function tile_word(s): the name of the function which returns the word 
%    and base point for tile S.
%
%    function grid_word(): the name of the function which returns the word
%    and base point for the grid.
%
  fprintf ( 1, '\n' );
  fprintf ( 1, 'solution_print():\n' );
  fprintf ( 1, '  MATLAB/Octave version %s\n', version ( ) );
  fprintf ( 1, '  Print, for each configuration in a solution,\n' );
  fprintf ( 1, '  the grid elements and (i,j) vertex\n' );
  fprintf ( 1, '  coordinates covered by the configuration.\n' );
%
%  Now go through the motions of generating every possible tile configuration.
%  When you have generated the word corresponding to a tile which is part of
%  the solution, add that to the plot.
%
  color = 0;
%
%  Define the region R.
%    W_R: boundary word for R.
%    PIJ_R: (I,J) coordinates of 30-degree node of triangle #1 of R.
%
  [ w_r, pij_r ] = grid_word ( );
%
%  Analyze the region R.
%    TK_R: for each triangle in R, the indices of the 30, 60, 90 degree nodes.
%    TT_R: for each triangle in R, the triangle type, between -6 and -1, or 1 and 6.
%    WIJ_R: (I,J) coordinates of the nodes of R.
%
  [ tk_r, tt_r, wij_r ] = triangle_k ( w_r, pij_r );

  element_num = size ( tt_r, 1 );
%
%  Allocate arrays:
%    A for the EQN_NUM x VAR_NUM linear system.
%    b for the EQN_NUM right hand side.
%    EQN_NUM = number of regions to cover and number of tiles to use.
%    VAR_NUM has to be determined, by generating all distinct tile configurations.
%
  eqn_num = element_num + tile_num;
  var_num = 0;
  A = zeros ( eqn_num, var_num );
  b = ones ( eqn_num, 1 );
%
%  Loop over tiles.
%
  for s = 1 : tile_num
%
%  Start a constraint row for this tile.
%
    eqn_cons = element_num + s;
%
%  Consider all counterclockwise tile rotations that are multiples of 60 degrees:
%  0, 60, 120, 180, 240, 300:
%
    for r = 0 : 5
%
%  Consider a tile or its reflection.
%
      for reflect = 0 : 1
%
%  Get a fresh copy of the word and base point.
%
        [ w_s, pij_s ] = tile_word ( s );
%
%  Perform R counterclockwise rotations of 60 degrees.
%
        [ w_s, pij_s ] = word_rotate_ij ( w_s, pij_s, r );
%
%  Perform REFLECT reflections across X axis.
%
        if ( reflect == 1 )
          [ w_s, pij_s ] = word_reflect_ij ( w_s, pij_s );
        end
%
%  Get the TYPE of the triangles that are the tile elements.
%    TK_S: for each triangle in S, the indices of the 30, 60, 90 degree nodes.
%    TT_S: for each triangle in S, the triangle type, between -6 and -1, or 1 and 6.
%    WIJ_S: (I,J) coordinates of the nodes of S.
%
        [ tk_s, tt_s, wij_s ] = triangle_k ( w_s, pij_s );
%
%  Get tile (i,j) coordinates of 30 degree node of tile triangle #1.
%
        jack_s = tk_s(1,1);
%
%  Key is the type of element #1.
%  We can only try to place this tile configuration starting at 
%  region elements of the same type as KEY.
%
        key = tt_s(1);
%
%  Consider triangle J in region R.
%
        for j = 1 : element_num
%
%  Does it match the type of triangle #1 of S?
%
          if ( tt_r(j) == key )
%
%  Determine the translation that would map triangle #1 of S to triangle J of R.
%
            jack_r = tk_r(j,1);
            pij_s = wij_r(jack_r,1:2) - wij_s(jack_s,1:2);
%
%  Does this configuration remain in the region R?
%
            [ inside, element ] = region_contains_tile ( w_r, pij_r, w_s, pij_s );
%
%  The configuration constitutes a new variable.
%  Update the equation of each triangle of R that is covered by the configuration.
%  Update the constraint equation for the tile.
%
            if ( inside )

              var_num = var_num + 1;

              if ( x(var_num) == 1 )

                fprintf ( 1, '  Configuration %d used in solution.\n', var_num );
                fprintf ( 1, '  Tile = %d, VAR_NUM = %d,', s, var_num );
                fprintf ( 1, '  Rotate = %d, reflect = %d,', r, reflect );
                fprintf ( 1, '  type = %d  pij = (%d,%d)\n', key, pij_s );
                [ t2kz, t2tz, wij_z ] = triangle_k ( w_s, pij_s );
%
%  Optionally print (i,j) coordinates of triangles.
%
                if ( false )
                  for ie = 1 : 36
                    i1 = t2kz(ie,1);
                    i2 = t2kz(ie,2);
                    i3 = t2kz(ie,3);
                    fprintf ( 1, '%4d  (%3d,%3d), (%3d,%3d), (%3d,%3d)\n', ...
                      ie, wij_z(i1,1), wij_z(i1,2), wij_z(i2,1), wij_z(i2,2), ...
                      wij_z(i3,1), wij_z(i3,2) )
                  end
                end

              end

            end % end configuration remains in region.

          end % end key match

        end  % end element search

      end  % end reflection check

    end  % end rotation check

  end  % end tile check
%
%  Terminate.
%
  fprintf ( 1, '\n' );
  fprintf ( 1, 'solution_print():\n' );
  fprintf ( 1, '  Normal end of execution.\n' );

  return
end
