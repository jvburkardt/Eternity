function solution_plot ( x, filename, label, grid_word, tile_num, tile_word )

%*****************************************************************************80
%
%% solution_plot() plots a solution generated by cplex().
%
%  Discussion:
%
%    This function assumes:
%    * there was an LP file generated;
%    * the linear system defined by the LP file was solved by cplex();
%    * the binary solution vector has been extracted by cplex_solution_read().
%
%    This function then produces a plot of the tiling of the region
%    as defined by the solution vector.
%
%  Licensing:
%
%    This code is distributed under the GNU LGPL license.
%
%  Modified:
%
%    24 November 2021
%
%  Author:
%
%    John Burkardt
%
%  Input:
%
%    integer X(*), the solution file.  Each 1 selects a configuration,
%    encoding the rotation, reflection and translation of a tile.
%
%    string FILENAME: the name of the plotfile.
%
%    string LABEL: a title to print with the plot.
%
  fprintf ( 1, '\n' );
  fprintf ( 1, 'solution_plot():\n' );
  fprintf ( 1, '  MATLAB/Octave version %s\n', version ( ) );
  fprintf ( 1, '  Plot a solution generated by cplex().\n' );
%
%  Now go through the motions of generating every possible tile configuration.
%  When you have generated the word corresponding to a tile which is part of
%  the solution, add that to the plot.
%
  color = 0;
%
%  Specify the number of tiles.
%
  tile_count = tile_num ( );
%
%  Define the region R.
%    W_R: boundary word for R.
%    PIJ_R: (I,J) coordinates of 30-degree node of triangle #1 of R.
%
  [ w_r, pij_r ] = grid_word ( );
  figure ( );
  region_grid_ij_plot ( w_r, pij_r );
  title ( label );
%
%  Analyze the region R.
%    TK_R: for each triangle in R, the indices of the 30, 60, 90 degree nodes.
%    TT_R: for each triangle in R, the triangle type, between -6 and -1, or 1 and 6.
%    WIJ_R: (I,J) coordinates of the nodes of R.
%
  [ tk_r, tt_r, wij_r ] = triangle_k ( w_r, pij_r );

  element_num = size ( tt_r, 1 );
%
%  Allocate arrays:
%    A for the EQN_NUM x VAR_NUM linear system.
%    b for the EQN_NUM right hand side.
%    EQN_NUM = number of regions to cover and number of tiles to use.
%    VAR_NUM has to be determined, by generating all distinct tile configurations.
%
  eqn_num = element_num + tile_count;
  var_num = 0;
  A = zeros ( eqn_num, var_num );
  b = ones ( eqn_num, 1 );
%
%  Loop over tiles.
%
  for s = 1 : tile_count
%
%  Start a constraint row for this tile.
%
    eqn_cons = element_num + s;
%
%  Consider all counterclockwise tile rotations that are multiples of 60 degrees:
%  0, 60, 120, 180, 240, 300:
%
    for r = 0 : 5
%
%  Consider a tile or its reflection.
%
      for reflect = 0 : 1
%
%  Get a fresh copy of the word and base point.
%
        [ w_s, pij_s ] = tile_word ( s );
%
%  Perform R counterclockwise rotations of 60 degrees.
%
        [ w_s, pij_s ] = word_rotate_ij ( w_s, pij_s, r );
%
%  Perform REFLECT reflections across X axis.
%
        if ( reflect == 1 )
          [ w_s, pij_s ] = word_reflect_ij ( w_s, pij_s );
        end
%
%  Get the TYPE of the triangles that are the tile elements.
%    TK_S: for each triangle in S, the indices of the 30, 60, 90 degree nodes.
%    TT_S: for each triangle in S, the triangle type, between -6 and -1, or 1 and 6.
%    WIJ_S: (I,J) coordinates of the nodes of S.
%
        [ tk_s, tt_s, wij_s ] = triangle_k ( w_s, pij_s );
%
%  Get tile (i,j) coordinates of 30 degree node of tile triangle #1.
%
        jack_s = tk_s(1,1);
%
%  Key is the type of element #1.
%  We can only try to place this tile configuration starting at 
%  region elements of the same type as KEY.
%
        key = tt_s(1);
%
%  Consider triangle J in region R.
%
        for j = 1 : element_num
%
%  Does it match the type of triangle #1 of S?
%
          if ( tt_r(j) == key )
%
%  Determine the translation that would map triangle #1 of S to triangle J of R.
%
            jack_r = tk_r(j,1);
            pij_s(1,1:2) = wij_r(jack_r,1:2) - wij_s(jack_s,1:2);
%
%  Does this configuration remain in the region R?
%
            [ inside, element ] = region_contains_tile ( w_r, pij_r, w_s, pij_s );
%
%  The configuration constitutes a new variable.
%  Update the equation of each triangle of R covered by the configuration.
%  Update the constraint equation for the tile.
%
            if ( inside )

              var_num = var_num + 1;

              if ( x(var_num) == 1 )
                fprintf ( 1, '  Tile = %d, VAR = %d,', s, var_num );
                fprintf ( 1, '  Rotate = %d, reflect = %d,', r, reflect );
                fprintf ( 1, '  type = %d  pij = (%d,%d)\n', key, pij_s );
                color = color + 1;
                tile_overlay_ij_plot ( w_s, pij_s, color );
              end

            end % end configuration remains in region.

          end % end key match

        end  % end element search

      end  % end reflection check

    end  % end rotation check

  end  % end tile check

  axis ( 'off' );

  print ( '-dpng', filename );
  fprintf ( 1, '  Graphics saved as "%s"\n', filename );
%
%  Terminate.
%
  fprintf ( 1, '\n' );
  fprintf ( 1, 'solution_plot():\n' );
  fprintf ( 1, '  Normal end of execution.\n' );

  return
end
